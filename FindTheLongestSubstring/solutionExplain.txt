解题思路
对于代码中一些变量的解释

这里由于只考虑每个元音奇偶次数，因此考虑用二进制来记录；

定义特征，aeiou 分别对应二进制 00001，00010，00100，01000，10000
其中 0 表示对应元音出现了偶数次数，1 表示奇数
从左往右遍历字符串，不断更新 dp；

dp[pattern] 的作用是用来记录当前索引值下对应的元音奇偶次数组合特征；
例如：如果 pattern 为 10，也就是对应二进制 01010，dp[pattern] = 8 的意思为，当索引值为 8 的时候，e 和 o 都出现了奇数次，其它元音为偶数次。

如何找到符合条件最大长度？

根据异或运算规律，异或本身为 0，所以当重复出现偶数次，对应位变为 0，否则为 1
由这个规律可以断定，当再次出现这个 pattern 的时候，一定出现了偶数次
为了方便解释，pattern 如下用二进制表示：
例如，pattern 的值变化为 31-->30-->28-->29-->31
对应的二进制位 [11111]-->[11110]-->[11100]-->[11101]-->[11111]
一个合理的字符串变化：aeiou --> aeioua -->aeiouae-->aeiouaea-->aeiouaeae
由此可见，从 aeiou 到 aeiouaeae 这个过程中，多余出来的 aeae 为符合条件的字符串
所以，在这个过程中，不管中间发生了什么样的变化，这两个状态之间对应的元音为偶数，也就是一定符合题意的字符串
因此，不断更新 res，来获得最大字符串长度
代码步骤解释

首先初始化 dp 长度为 32，对应了 5 个元音每个次数或奇或偶一共 32 种状态
异或运算部分：
遍历字符串，从起始 pattern，也就是 0 开始，不断根据对应情况做异或运算
如果出现的是辅音，不进行异或运算
如果出现的是元音，根据元音种类分别对应做异或运算
答案更新：
如果当前的 pattern 没有出现过，那么以这个 pattern 为键，记录下当前位置，也就是索引的位置
如果出现过，那么更新目标长度：
这里有两种情况：
当前如果不是元音，相当于 i 变化了 1，而 dp[pattern] 不变，相当于辅音的时候直接增加 1 的长度
如果是元音，说明出现了偶数次的元音，那么 i-dp[pattern] 相当于在原来基础上增加了一部分长度，这一部分长度满足偶数次的元音
举个例子，s='leetcodeo'

dp[0]=-1，为了计算长度方便定义，或者理解为，开始计算前，参照点在第一个字符之前，也就是 -1 的位置
i=0，l 不是元音，pattern 不变，
i=1，e 是元音，pattern 变化，由 0 变为 2，二进制下为 [00010] dp对应当前 pattern 对应索引更新为 1
i=2，e 是元音，pattern 变化，由 2 变为 0，二进制下为 [00000] 即初始状态，更新 res 为 2-(-1) = 3
i=3，t 不是元音，pattern 不变，res 更新为 3-(-1) = 4
i=4，c 不是元音，pattern 不变，res 更新为 4-(-1) = 5
i=5，o 是元音，pattern变化，由 0 变为 8，二进制下为 [01000]，dp 对应当前 pattern 对应索引更新为 5
i=6，d 不是元音，pattern 不变，对应 cur_len 为 6-5=1`，没有 5 大，所以当前 res 还是 5
i=7，e 是元音，pattern 变化，由 8 变为 10，二进制下为 [01010]，dp 对应当前 pattern 对应索引更新为 7
i=8，o 是元音，pattern 变化，由 10 变为 2，二进制下为 [00010]，由于这个 pattern 在 i=1 出现过，所以用这个对应的 i 来更新 cur_len = i-dp[pattern] = 8-1 = 7，同时 res 更新到 7
遍历结束，结果为 7

作者：will_never_die
链接：https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solution/xiang-xi-jie-shi-by-will_never_die/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。